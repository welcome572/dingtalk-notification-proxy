from fastapi import FastAPI, HTTPException
import logging
import requests
import json
import hmac
import hashlib
import base64
import time
import urllib.parse
from datetime import datetime
import yaml
import os

# è®¾ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# åŠ è½½é…ç½®
def load_config():
    try:
        config_path = os.path.join('config', 'config.yaml')
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except Exception as e:
        logger.error(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
        return {}

config = load_config()
dingtalk_config = config.get('dingtalk', {}).get('webhooks', {}).get('default', {})

app = FastAPI(
    title="DingTalké€šçŸ¥ä¸­è½¬æœåŠ¡",
    description="å…¨ç±»å‹é€šçŸ¥ä¸­è½¬æœåŠ¡",
    version="7.2.0"
)

class DingTalkSender:
    @staticmethod
    def generate_signature(secret: str) -> dict:
        timestamp = str(round(time.time() * 1000))
        secret_enc = secret.encode('utf-8')
        string_to_sign = f'{timestamp}\n{secret}'
        string_to_sign_enc = string_to_sign.encode('utf-8')
        hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
        sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
        return {"timestamp": timestamp, "sign": sign}

    @staticmethod
    def send_to_dingtalk(webhook_url: str, secret: str, message: dict) -> dict:
        try:
            signature = DingTalkSender.generate_signature(secret)
            full_url = f"{webhook_url}&timestamp={signature['timestamp']}&sign={signature['sign']}"
            
            headers = {'Content-Type': 'application/json'}
            logger.info(f"å‘é€é’‰é’‰æ¶ˆæ¯: {json.dumps(message, ensure_ascii=False)}")
            response = requests.post(full_url, data=json.dumps(message, ensure_ascii=False), headers=headers, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            
            if result.get('errcode') == 0:
                logger.info("é’‰é’‰æ¶ˆæ¯å‘é€æˆåŠŸ")
                return {"success": True, "message_id": result.get('msgid')}
            else:
                logger.error(f"é’‰é’‰APIé”™è¯¯: {result.get('errmsg')}")
                return {"success": False, "error": result.get('errmsg')}
                
        except Exception as e:
            logger.error(f"å‘é€é’‰é’‰æ¶ˆæ¯å¤±è´¥: {str(e)}")
            return {"success": False, "error": str(e)}

def detect_project_type(data: dict) -> str:
    """æ£€æµ‹é¡¹ç›®ç±»å‹å¹¶è¿”å›é¡¹ç›®åç§°"""
    # å°†æ•°æ®è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ£€æµ‹
    data_str = json.dumps(data, ensure_ascii=False).lower()
    
    # Embyé¡¹ç›®æ£€æµ‹ - ç²¾ç¡®æ£€æµ‹Embyç‰¹æœ‰å­—æ®µ
    if 'Event' in data and 'Item' in data and 'Session' in data:
        return 'Emby'
    
    # CASé¡¹ç›®æ£€æµ‹ (cloud189-auto-save) - æ‰©å±•å…³é”®è¯ï¼ŒåŒ…æ‹¬embyå…¥åº“ç›¸å…³
    cas_keywords = [
        'strm', 'strmæ–‡ä»¶', 'ç”Ÿæˆstrm', 'æ–‡ä»¶å®Œæˆ',
        'æ€»æ–‡ä»¶æ•°', 'æˆåŠŸæ•°', 'å¤±è´¥æ•°', 'è·³è¿‡æ•°',
        'cloud189', 'å¤©ç¿¼äº‘ç›˜', 'auto-save', 'è¿½æ›´',
        'embyå…¥åº“', 'emby', 'å…¥åº“', 'æŠ“å¨ƒå¨ƒ', 'å§å§å¦¹å¦¹',
        'å†·å®«', 'maternity', 'matron', 'ç”Ÿæˆ', 'å®Œæˆ'
    ]
    
    # æ£€æŸ¥æ•°æ®ä¸­æ˜¯å¦åŒ…å«CASå…³é”®è¯
    for keyword in cas_keywords:
        if keyword in data_str:
            return 'CAS'
    
    # ç›‘æ§é¡¹ç›®æ£€æµ‹
    if any(keyword in data_str for keyword in ['prometheus', 'alertmanager', 'zabbix', 'ç›‘æ§', 'å‘Šè­¦']):
        return 'ç›‘æ§'
    
    # Gité¡¹ç›®æ£€æµ‹
    if any(keyword in data_str for keyword in ['git', 'repository', 'commit', 'push', 'pull']):
        return 'Git'
    
    # Dockeré¡¹ç›®æ£€æµ‹
    if any(keyword in data_str for keyword in ['docker', 'container', 'kubernetes']):
        return 'Docker'
    
    # å¤‡ä»½é¡¹ç›®æ£€æµ‹
    if any(keyword in data_str for keyword in ['backup', 'å¤‡ä»½', 'restic', 'borg']):
        return 'å¤‡ä»½'
    
    # å¦‚æœæ— æ³•è¯†åˆ«å…·ä½“é¡¹ç›®ï¼Œè¿”å›"ç³»ç»Ÿ"
    return 'ç³»ç»Ÿ'

def parse_emby_notification(data: dict) -> str:
    """ä¸“é—¨è§£æEmbyé€šçŸ¥ï¼Œè¿”å›ä¸­æ–‡æ ¼å¼çš„æ¶ˆæ¯å†…å®¹"""
    event = data.get('Event', '')
    user = data.get('User', {}).get('Name', 'æœªçŸ¥ç”¨æˆ·')
    item_name = data.get('Item', {}).get('Name', '')
    series_name = data.get('Item', {}).get('SeriesName', '')
    device = data.get('Session', {}).get('DeviceName', 'æœªçŸ¥è®¾å¤‡')
    client = data.get('Session', {}).get('Client', 'æœªçŸ¥å®¢æˆ·ç«¯')
    
    # äº‹ä»¶ç±»å‹æ˜ å°„ä¸ºä¸­æ–‡ - å·²ä¼˜åŒ–"ç»§ç»­æ’­æ”¾"ä¸ºä¸­æ–‡
    event_translations = {
        'playback.start': 'å¼€å§‹æ’­æ”¾',
        'playback.stop': 'åœæ­¢æ’­æ”¾', 
        'playback.pause': 'æš‚åœæ’­æ”¾',
        'playback.resume': 'ç»§ç»­æ’­æ”¾',
        'user.authenticated': 'ç”¨æˆ·ç™»å½•',
        'user.locked.out': 'ç”¨æˆ·é”å®š',
        'session.start': 'ä¼šè¯å¼€å§‹',
        'session.end': 'ä¼šè¯ç»“æŸ',
        'system.notification': 'ç³»ç»Ÿé€šçŸ¥'
    }
    
    event_cn = event_translations.get(event, event)
    
    # æ„å»ºä¸­æ–‡å†…å®¹
    content_parts = []
    
    if user and user != 'æœªçŸ¥ç”¨æˆ·':
        content_parts.append(f"**ğŸ‘¤ ç”¨æˆ·:** {user}")
    
    if item_name:
        if series_name:
            content_parts.append(f"**ğŸ“º å‰§é›†:** {series_name} - {item_name}")
        else:
            content_parts.append(f"**ğŸ“„ å†…å®¹:** {item_name}")
    
    if device and device != 'æœªçŸ¥è®¾å¤‡':
        content_parts.append(f"**ğŸ’» è®¾å¤‡:** {device} ({client})")
    
    content_parts.append(f"**ğŸ¯ äº‹ä»¶:** {event_cn}")
    
    return "\n".join(content_parts)

def parse_notification(data: dict) -> dict:
    """ç»Ÿä¸€è§£æé€šçŸ¥"""
    # æ£€æµ‹é¡¹ç›®ç±»å‹
    project_type = detect_project_type(data)
    logger.info(f"æ£€æµ‹åˆ°é¡¹ç›®ç±»å‹: {project_type}")
    
    # å¦‚æœæ˜¯Embyé¡¹ç›®ï¼Œä½¿ç”¨ä¸“é—¨çš„è§£æå™¨
    if project_type == 'Emby':
        message = parse_emby_notification(data)
    else:
        # å…¶ä»–é¡¹ç›®çš„æ¶ˆæ¯å†…å®¹æå–
        message = data.get('message', data.get('content', data.get('text', data.get('body', ''))))
        
        # å¦‚æœæ¶ˆæ¯æ˜¯å­—å…¸ï¼Œè½¬æ¢ä¸ºæ ¼å¼åŒ–çš„å­—ç¬¦ä¸²
        if isinstance(message, dict):
            message_parts = []
            for key, value in message.items():
                if isinstance(value, (str, int, float, bool)):
                    message_parts.append(f"**{key}:** {value}")
            message = "\n".join(message_parts) if message_parts else ""
        
        # å¦‚æœæ²¡æœ‰æ¶ˆæ¯å†…å®¹ï¼Œä½¿ç”¨æ•°æ®ä¸­çš„å…¶ä»–ä¿¡æ¯
        if not message:
            message_parts = []
            for key, value in data.items():
                if key not in ['title', 'Title', 'subject'] and isinstance(value, (str, int, float, bool)):
                    message_parts.append(f"**{key}:** {value}")
            message = "\n".join(message_parts) if message_parts else "æ”¶åˆ°æ–°çš„é€šçŸ¥"
    
    # æ ¹æ®é¡¹ç›®ç±»å‹è®¾ç½®å›¾æ ‡
    icon_configs = {
        'Emby': 'ğŸ¬',
        'CAS': 'ğŸ“¥', 
        'ç›‘æ§': 'âš ï¸',
        'Git': 'ğŸ”—',
        'Docker': 'ğŸ³',
        'å¤‡ä»½': 'ğŸ’¾',
        'ç³»ç»Ÿ': 'ğŸ“¢'
    }
    icon = icon_configs.get(project_type, 'ğŸ“¢')
    
    # çŠ¶æ€æ£€æµ‹
    message_str = str(message).lower()
    if any(word in message_str for word in ['å¤±è´¥', 'é”™è¯¯', 'error']):
        icon = 'âŒ'
    elif any(word in message_str for word in ['å®Œæˆ', 'æˆåŠŸ', 'success']):
        icon = 'âœ…'
    elif any(word in message_str for word in ['è­¦å‘Š', 'warning']):
        icon = 'âš ï¸'
    
    return {
        "msgtype": "markdown",
        "markdown": {
            "title": f"{icon} {project_type}é€šçŸ¥",
            "text": f"""## {icon} {project_type}é€šçŸ¥

{message}

**â° æ—¶é—´:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"""
        }
    }

@app.get("/")
async def root():
    return {"message": "å…¨ç±»å‹é€šçŸ¥ä¸­è½¬æœåŠ¡", "version": "7.2.0"}

@app.get("/health")
async def health():
    return {"status": "healthy", "service": "dingtalk-notification-proxy"}

@app.post("/api/v1/webhook/dingtalk")
async def dingtalk_webhook_v1(data: dict):
    return await process_webhook(data)

@app.post("/webhook")
async def webhook_compatible(data: dict):
    return await process_webhook(data)

@app.post("/dingtalk")
async def dingtalk_compatible(data: dict):
    return await process_webhook(data)

@app.post("/{path:path}")
async def catch_all_webhook(path: str, data: dict):
    logger.info(f"æ”¶åˆ°è·¯å¾„ /{path} çš„webhookè¯·æ±‚")
    return await process_webhook(data)

async def process_webhook(data: dict):
    try:
        logger.info(f"æ”¶åˆ°åŸå§‹æ•°æ®: {json.dumps(data, ensure_ascii=False)}")
        
        if not dingtalk_config.get('url') or not dingtalk_config.get('secret'):
            raise HTTPException(status_code=500, detail="é’‰é’‰é…ç½®ä¸å®Œæ•´")
        
        # ç›´æ¥è§£æé€šçŸ¥
        dingtalk_message = parse_notification(data)
        
        logger.info(f"å‡†å¤‡å‘é€çš„é’‰é’‰æ¶ˆæ¯: {json.dumps(dingtalk_message, ensure_ascii=False)})")
        
        result = DingTalkSender.send_to_dingtalk(
            dingtalk_config["url"],
            dingtalk_config["secret"],
            dingtalk_message
        )
        
        if result["success"]:
            return {
                "success": True,
                "message": "é€šçŸ¥å·²å‘é€åˆ°é’‰é’‰"
            }
        else:
            raise HTTPException(status_code=500, detail=f"é’‰é’‰å‘é€å¤±è´¥: {result.get('error')}")
            
    except Exception as e:
        logger.error(f"å¤„ç†webhookå¤±è´¥: {str(e)}")
        raise HTTPException(status_code=500, detail=f"å¤„ç†å¤±è´¥: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
